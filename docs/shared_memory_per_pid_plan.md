# 共享内存按 PID 隔离实施方案（方案二）

## 需求审核（Code Prompt Coach）

**清晰性**  
需求目标明确：将共享内存按 PID 隔离，避免多进程互相影响，并要求输出可落地的实施方案文档。

**具体性**  
已给出当前注入器配置与 `dnfinput` 关键代码片段，但**控制端（写共享内存端）代码位置与实现细节未提供**，因此方案中会明确标注“待确认/待补充”的实现点。

**上下文**  
已知：  
- 注入器为 APC 方式，多进程 `dnf.exe` 同时注入 `GameHelper.dll` 与 `dnfinput.dll`  
- `dnfinput` 通过 `Local\\DNFSyncBox.KeyboardState.V2` 共享内存读同步数据  
未知（需补充）：  
- 控制端程序/工程路径（创建共享内存的一侧）  
- 控制端是否支持多进程列表与 per-PID 推送  
- 现有共享内存创建权限/安全描述符

**结构与格式**  
本方案将按：目标 → 设计 → 详细步骤 → 兼容与回滚 → 测试 → 风险与观察点 的结构展开。

---

## 目标

将输入同步共享内存改为“**每 PID 一份**”，消除第二进程注入后对第一进程的间接影响，提升多开稳定性与可控性。

---

## 总体设计

**核心思路：**  
共享内存命名从固定名改为 **带 PID 的动态名**，每个客户端只读取属于自己的共享区。

**命名格式建议：**  
```
Local\\DNFSyncBox.KeyboardState.V2.{pid}
```

**兼容策略（强烈建议）：**  
1. DLL 侧优先打开带 PID 的共享内存  
2. 失败时 **回退到旧的全局名**（保证老控制端仍可用）  
3. 控制端升级后，逐步关闭旧的全局名写入

---

## 影响范围

**必须修改：**
1. `dnfinput.dll`（读共享内存的一侧）  
2. 控制端程序（写共享内存的一侧）

**可选修改：**
1. 注入器日志增强（记录注入 PID 与模块名，便于排查）  
2. 配置项开关（便于快速切换新旧模式）

---

## 详细实施步骤

### 阶段一：DLL 端（dnfinput）改造

**步骤 1：新增“共享内存名称构造函数”**  
在 `dnfinput` 中加入函数：

```
BuildSharedMemoryName(pid) => L"Local\\DNFSyncBox.KeyboardState.V2.{pid}"
```

并保留旧名 `Local\\DNFSyncBox.KeyboardState.V2` 作为回退。

**步骤 2：修改共享内存打开逻辑（EnsureSharedMemory）**

建议顺序：
1. 先尝试打开 PID 专属名  
2. 失败再尝试旧名  
3. 日志记录当前使用的共享内存名称

**理由：**  
这一步能实现平滑过渡，不强制控制端同时更新。

**步骤 3：日志增强**
记录如下内容，便于定位多进程问题：
- 使用的共享内存名称  
- 共享内存 version  
- lastTick 延迟  
- activePid/selfPid

---

### 阶段二：控制端改造（写共享内存）

**步骤 1：按 PID 创建共享内存**
控制端对每个目标进程创建：
```
Local\\DNFSyncBox.KeyboardState.V2.{pid}
```

**步骤 2：写入结构时设置 activePid**
建议写入：
```
activePid = pid
```
保证 DLL 侧 `IsBypassProcess` 判断始终成立，避免“伪造逻辑”误触发。

**步骤 3：保留旧共享内存（可选，兼容期）**
若需兼容旧 DLL，可在短期内同时写入：
```
Local\\DNFSyncBox.KeyboardState.V2
```
待全部 DLL 升级后再移除。

---

### 阶段三：配置与开关（可选，但推荐）

新增配置项（控制端 + DLL）：
```
shared_memory_per_pid = true/false
```

**理由：**  
出现问题时可快速回退到旧模式，不影响生产环境稳定性。

---

## 兼容与回滚策略

**兼容策略（推荐实施顺序）：**
1. 先改 DLL：支持“PID 专属名 + 旧名回退”  
2. 再改控制端：开始按 PID 写共享内存  
3. 稳定后移除旧名写入

**回滚方式：**
- DLL 侧强制走旧名  
- 控制端关闭 per-PID 模式

---

## 测试计划

1. **单进程测试**  
   - 验证共享内存能正常读取  
   - activePid == selfPid  

2. **双进程测试**  
   - 同时注入两个进程  
   - 两个进程读取不同共享内存  
   - 操作互不影响（无卡死/闪退）

3. **压力测试**  
   - 多开 3~5 个客户端  
   - 长时间运行（30-60 分钟）

4. **兼容测试**  
   - 新 DLL + 旧控制端  
   - 旧 DLL + 新控制端（如需）

---

## 风险与对策

**风险 1：控制端未升级导致无法连接**  
对策：DLL 回退旧共享内存名。

**风险 2：activePid 逻辑变化导致伪造输入失效**  
对策：明确规范 activePid 语义 = selfPid，或新增单独字段 `ownerPid`。

**风险 3：多进程共享内存数量上升**  
对策：每进程 1 份，体积约 1KB 级别，风险可忽略。

---

## 需要补充的关键信息（落地前必须确认）

1. 控制端代码位置与工程名称  
2. 控制端创建共享内存的具体实现  
3. 是否需要跨 Session 支持（Local vs Global）  
4. 是否已有“多进程状态”管理模块

---

## 交付物清单

- [ ] `dnfinput`：共享内存按 PID 改造（含回退策略）  
- [ ] 控制端：按 PID 写共享内存  
- [ ] 可选：新增开关配置项  
- [ ] 测试记录与日志核验结果

