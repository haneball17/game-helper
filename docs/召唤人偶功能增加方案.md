### 核心设计方案

为了保证代码的可维护性和稳定性，我不建议直接在按键检测的地方写一大堆汇编代码。我们要采用**“分层封装”**的设计模式。

#### 1. 设计架构

* **层级一：数据层 (`基址.h`)**
* 定义基址常量。将来版本更新，只需要改这一个文件，不需要去改函数逻辑。


* **层级二：功能层 (`CALL.cpp` / `CALL.h`)**
* 将 CE 的汇编脚本“翻译”为 C++ 函数 `Call_SummonDoll(int id)`。
* **优势**：我们将复杂的参数（如 ID、等级、坐标）参数化。下次你想把 F12 改成召唤别的怪物，只需要传不同的参数，不用重写汇编。


* **层级三：控制层 (`dllmain.cpp` 或 `自动.cpp`)**
* 监听 F12 按键。
* 调用 `Call_SummonDoll`。
* **优势**：逻辑清晰，按键归按键，功能归功能。



#### 2. 举例说明优势

* **如果不设计（直接写死）**：你在 `if(F12)` 里写了 20 行 `__asm` 代码。过两天你想把 F11 设置为召唤另一个怪，你又复制了 20 行代码。代码变得臃肿且难以维护。
* **采用本设计**：
* F12: `Call_SummonDoll(25301);` // 召唤人偶
* F11: `Call_SummonDoll(62142);` // 召唤另一个
* 代码极其简洁，复用性高。



---

### 详细实施步骤

请按照以下顺序修改你的 `game-helper` 项目文件。

#### 第一步：定义基址与偏移

打开 **`DNFHelper/基址.h`** (或 `2017.1.25基址.h`)，确认或添加以下定义。虽然你已经在代码里有了 `1AC790C`，但最好给它个名字。

```cpp
// 在 基址.h 中添加
#ifndef BASE_ADDR_0725
#define BASE_ADDR_0725 0x01AC790C // 0725版本人物基址
#endif

```

#### 第二步：封装召唤函数

我们需要在 **`DNFHelper/CALL.cpp`** 中实现这个功能，并在 **`DNFHelper/CALL.h`** 中声明它。

**1. 修改 `DNFHelper/CALL.h**`
在文件末尾（类定义内或全局函数声明处）添加声明：

```cpp
// 召唤人偶/怪物函数声明
// monsterId: 怪物代码 (如 25301)
// level: 等级 (默认 70)
void Call_SummonDoll(int monsterId, int level = 70);

```

**2. 修改 `DNFHelper/CALL.cpp**`
这是最关键的一步，我们需要把 CE 汇编翻译成 C++ 内联汇编。
*注意：CE 脚本中的 `Call EBX` 是基于动态计算的地址，这在 C++ 中需要精确还原指针计算逻辑。*

```cpp
#include "stdafx.h"
#include "CALL.h"
#include "基址.h" // 确保包含定义了 BASE_ADDR_0725 的头文件

void Call_SummonDoll(int monsterId, int level)
{
    // 定义常量，方便汇编引用
    DWORD BaseAddr = BASE_ADDR_0725; 
    
    // 为了防止崩溃，先判断基址是否有效
    if (IsBadReadPtr((void*)BaseAddr, 4)) return;
    DWORD playerBase = *(DWORD*)BaseAddr;
    if (playerBase == 0) return;

    // 内联汇编开始
    __asm
    {
        pushad              // 保护寄存器

        // --- 开始压栈参数 (从下往上压，对应 CE 的 Push 顺序) ---
        
        Push 0
        Push 1              // 升级特效?
        Push 0x119FEF0      // 召唤CALL的某个参数 (可能是固定的call地址或标志)
        Push 0
        Push 0
        Push -1             // -1
        Push 0
        Push 0
        Push 0
        Push 1
        Push 0
        Push 0
        Push 0x8AE          // 位置/距离?
        Push level          // 参数：等级 (CE中是 #70)
        Push 0              // 阵营
        Push monsterId      // 参数：人偶代码 (CE中是 #25301)

        // --- 计算 Call 的地址 ---
        // 原理：[[[Base]+0]+354]
        
        Mov ESI, playerBase // ESI = [1AC790C]
        Mov ECX, ESI        // ECX = ESI (ECX通常是this指针)
        
        // CE: Mov EDX,[ECX+0] -> Mov EAX,EDX -> Add EAX,354 -> Mov EBX,[EAX+0]
        Mov EDX, [ECX]      // 取对象头/虚表
        Mov EAX, EDX
        Add EAX, 0x354      // 加上偏移 354
        Mov EBX, [EAX]      // 取出最终的函数地址

        // --- 执行 Call ---
        Call EBX

        popad               // 恢复寄存器
    }
}

```

#### 第三步：绑定按键 F12

找到项目的入口循环，通常在 **`DNFHelper/dllmain.cpp`** 或者 **`DNFHelper/自动.cpp`** 中有一个 `while(true)` 的循环线程。

假设你在 `dllmain.cpp` 中有一个主线程函数（根据你上传的文件，可能是 `HelperStart` 或注入后的主逻辑）：

**在 `DNFHelper/dllmain.cpp` (或其他包含主循环的文件) 中：**

```cpp
#include "CALL.h" // 引入刚才写的函数

// ... 在你的线程循环函数中 ...

DWORD WINAPI MyLoopThread(LPVOID lpParam)
{
    while (true)
    {
        // ... 其他逻辑 ...

        // 检测 F12 按键
        // GetAsyncKeyState 返回值的最高位为1表示当前键被按下
        // & 1 表示“刚刚按下”（防止按住不放一直召唤，导致显卡爆炸）
        if (GetAsyncKeyState(VK_F12) & 1) 
        {
            // 调用我们封装好的函数
            Call_SummonDoll(25301, 70); 
            
            // 简单的防抖提示 (可选)
            // OutputDebugStringA("F12 Pressed: Summoning Doll...");
        }

        Sleep(10); // 防止 CPU 占用过高
    }
    return 0;
}

```

### 验证与调试

1. **编译检查**：确保包含头文件路径正确，`BASE_ADDR_0725` 已定义。
2. **安全性检查**：
* 我在代码中加入了 `IsBadReadPtr` 和 `playerBase == 0` 的判断。这是为了防止你在**选人界面**或**游戏未加载完成**时按 F12 导致游戏直接崩溃（CE 脚本通常没有这些保护，很容易崩）。


3. **功能验证**：
* 进入游戏（进图）。
* 按下 F12。
* 观察是否有人偶出现。
